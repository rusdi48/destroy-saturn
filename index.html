<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/jpeg" href="saturn.jpg">
    <title>Destroy Saturn</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            overflow: hidden;
            color: #fff;
            touch-action: manipulation;
        }

        #planetCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #camera {
            display: none;
        }

        #statusPanel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #222;
            min-width: 250px;
            z-index: 100;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.8);
        }

        #statusPanel.mobile {
            padding: 15px;
            min-width: 200px;
            font-size: 0.9em;
        }

        #statusPanel h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #ffa500;
            text-shadow: 0 0 12px rgba(255, 165, 0, 0.7);
            letter-spacing: 1px;
        }

        #statusPanel p {
            margin: 6px 0;
            font-size: 14px;
        }

        .status-label {
            color: #999;
            font-weight: 500;
        }

        .status-value {
            color: #0f0;
            font-weight: bold;
            text-shadow: 0 0 6px rgba(0, 255, 0, 0.6);
        }
        
        .panel-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          cursor: pointer;
          margin-bottom: 10px;
          user-select: none;
        }
        
        .panel-header h2 {
          margin-bottom: 0;
        }
        
        #togglePanelBtn {
          background: rgba(255, 165, 0, 0.2);
          border: 1px solid rgba(255, 165, 0, 0.5);
          color: #ffa500;
          width: 24px;
          height: 24px;
          border-radius: 5px;
          cursor: pointer;
          font-size: 16px;
          display: flex;
          align-items: center;
          justify-content: center;
          transition: all 0.3s ease;
          margin: -12px 0 0 12px;
        }
        
        #togglePanelBtn:hover {
          background: rgba(255, 165, 0, 0.3);
          border-color: #ffa500;
        }
        
        .panel-content {
          overflow: hidden;
          transition: max-height 0.3s ease, opacity 0.3s ease;
        }
        
        .panel-content.collapsed {
          max-height: 0;
          opacity: 0;
        }
        
        .panel-content.expanded {
          max-height: 500px;
          opacity: 1;
        }
        
        #flashOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,200,100,0.8) 50%, rgba(255,100,0,0) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 50;
            transition: opacity 0.05s;
        }

        #shakeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(255, 0, 0, 0);
            pointer-events: none;
            z-index: 45;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
            background: rgba(0, 0, 0, 0.6);
            padding: 2rem;
            border-radius: 16px;
            
            border: 2px solid #222;
            
            backdrop-filter: blur(10px);
            
        }

        #loading h1 {
            font-size: 28px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 165, 0, 1);
            letter-spacing: 1.5px;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid #ffa500;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 0.8s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .instruction {
            margin-top: 15px;
            font-size: 12px;
            color: #666;
            line-height: 1.6;
        }

        .mobile-warning {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 165, 0, 0.8);
            color: #000;
            padding: 10px 20px;
            border-radius: 12px;
            font-weight: bold;
            z-index: 150;
            text-align: center;
            max-width: 90%;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            font-size: 14px;
        }

        @media (max-width: 768px) {
            #statusPanel {
                top: 10px;
                left: 10px;
                padding: 12px 15px;
                min-width: 180px;
            }
            
            #statusPanel h2 {
                font-size: 16px;
            }
            
            #statusPanel p {
                font-size: 12px;
            }
            
            #togglePanelBtn {
              width: 20px;
              height: 20px;
              font-size: 14px;
              margin-top: -10px;
            }
            
            .instruction {
                font-size: 10px;
            }
            
            #loading h1 {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div id="flashOverlay"></div>
    <div id="shakeOverlay"></div>
    
    <div class="mobile-warning" id="mobileWarning">
        Mobile Mode: Animations optimized for performance
    </div>

    <div id="loading">
        <h1>DESTROY SATURN</h1>
        <div class="spinner"></div>
        <p style="margin-top: 20px; font-size: 14px;">Initializing systems...</p>
        <p id="deviceInfo" style="margin-top: 10px; font-size: 12px; color: #888;"></p>
    </div>

<div id="statusPanel" style="display: none;">
    <div class="panel-header">
        <h2>SATURN CONTROL</h2>
        <button id="togglePanelBtn">‚ñº</button>
    </div>
    
    <div class="panel-content expanded" id="panelContent">
        <p><span class="status-label">Hand:</span> <span id="handStatus" class="status-value">No</span></p>
        <p><span class="status-label">Gesture:</span> <span id="gestureStatus" class="status-value">None</span></p>
        <p><span class="status-label">Status:</span> <span id="planetStatus" class="status-value">Normal</span></p>
        <p><span class="status-label">Device:</span> <span id="deviceMode" class="status-value">Desktop</span></p>
        <div class="instruction">
            ‚úä <strong>Fist</strong> - Destroy Saturn<br>
            ‚úã <strong>Open</strong> - Restore Saturn<br>
        </div>
    </div>
</div>

    <video id="camera" autoplay playsinline></video>
    <canvas id="planetCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <script>
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isTablet = /iPad|Tablet|PlayBook|Silk/i.test(navigator.userAgent);
        
        const deviceConfig = {
            isMobile: isMobile || isTablet,
            particleCount: isMobile ? 150 : 300,
            debrisCount: isMobile ? 25 : 50,
            starCount: isMobile ? 1500 : 3000,
            geometrySegments: isMobile ? 64 : 256,
            ringSegments: isMobile ? 128 : 256,
            textureSize: isMobile ? 512 : 1024,
            shadowQuality: isMobile ? 2048 : 4096,
            animationFrames: isMobile ? 60 : 100,
            gestureHoldThreshold: isMobile ? 3 : 5
        };

        let isDestroyed = false;
        let isAnimating = false;
        let currentGesture = 'none';
        let currentAnimation = null;
        let gestureHoldTime = 0;
        const GESTURE_HOLD_THRESHOLD = deviceConfig.gestureHoldThreshold;
        
        const canvas = document.getElementById('planetCanvas');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03);
        
        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 7);

        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvas,
            antialias: !deviceConfig.isMobile,
            alpha: true,
            powerPreference: deviceConfig.isMobile ? "low-power" : "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, deviceConfig.isMobile ? 1.5 : 2));
        renderer.shadowMap.enabled = !deviceConfig.isMobile;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = deviceConfig.isMobile ? THREE.LinearToneMapping : THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = deviceConfig.isMobile ? 1.1 : 1.3;
        
        const ambientLight = new THREE.AmbientLight(0x404040, deviceConfig.isMobile ? 0.8 : 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xfff8e1, deviceConfig.isMobile ? 1.5 : 2.5);
        sunLight.position.set(10, 6, 10);
        if (!deviceConfig.isMobile) {
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = deviceConfig.shadowQuality;
            sunLight.shadow.mapSize.height = deviceConfig.shadowQuality;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 50;
        }
        scene.add(sunLight);

        const rimLight1 = new THREE.DirectionalLight(0x4488ff, deviceConfig.isMobile ? 0.8 : 1.2);
        rimLight1.position.set(-8, 3, -8);
        scene.add(rimLight1);

        const rimLight2 = new THREE.DirectionalLight(0xff8844, deviceConfig.isMobile ? 0.5 : 0.8);
        rimLight2.position.set(8, -3, -8);
        scene.add(rimLight2);

        const glowLight = new THREE.PointLight(0xffcc66, 1, 30);
        glowLight.position.set(0, 0, 5);
        scene.add(glowLight);
        
        const saturnGeometry = new THREE.SphereGeometry(1.4, deviceConfig.geometrySegments, deviceConfig.geometrySegments);
        
        const saturnCanvas = document.createElement('canvas');
        saturnCanvas.width = deviceConfig.textureSize;
        saturnCanvas.height = deviceConfig.textureSize;
        const ctx = saturnCanvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 0, deviceConfig.textureSize);
        if (deviceConfig.isMobile) {
            gradient.addColorStop(0, '#f5e6d3');
            gradient.addColorStop(0.3, '#e8c468');
            gradient.addColorStop(0.6, '#c9974d');
            gradient.addColorStop(1, '#f5e6d3');
        } else {
            gradient.addColorStop(0, '#f5e6d3');
            gradient.addColorStop(0.15, '#e8c468');
            gradient.addColorStop(0.3, '#d4a76a');
            gradient.addColorStop(0.45, '#c9974d');
            gradient.addColorStop(0.6, '#e8c468');
            gradient.addColorStop(0.75, '#d4a76a');
            gradient.addColorStop(0.9, '#c9a165');
            gradient.addColorStop(1, '#f5e6d3');
        }
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, deviceConfig.textureSize, deviceConfig.textureSize);
        
        const textureDetail = deviceConfig.isMobile ? 25 : 50;
        for (let y = 0; y < deviceConfig.textureSize; y += deviceConfig.isMobile ? 2 : 1) {
            for (let x = 0; x < textureDetail; x++) {
                const px = Math.random() * deviceConfig.textureSize;
                const brightness = (Math.random() - 0.5) * (deviceConfig.isMobile ? 40 : 60);
                ctx.fillStyle = `rgba(${brightness > 0 ? 255 : 0}, ${brightness > 0 ? 255 : 0}, ${brightness > 0 ? 200 : 0}, ${Math.abs(brightness) / 200})`;
                ctx.fillRect(px, y, deviceConfig.isMobile ? 3 : 2, deviceConfig.isMobile ? 2 : 1);
            }
        }
        
        const saturnTexture = new THREE.CanvasTexture(saturnCanvas);
        saturnTexture.wrapS = THREE.RepeatWrapping;
        saturnTexture.wrapT = THREE.RepeatWrapping;
        
        const saturnMaterial = new THREE.MeshPhongMaterial({
            map: saturnTexture,
            shininess: deviceConfig.isMobile ? 30 : 50,
            specular: 0x666666,
            bumpScale: 0.05
        });
        
        const saturn = new THREE.Mesh(saturnGeometry, saturnMaterial);
        saturn.castShadow = !deviceConfig.isMobile;
        saturn.receiveShadow = !deviceConfig.isMobile;
        scene.add(saturn);
        
        const ringGeometry = new THREE.RingGeometry(1.8, 3.4, deviceConfig.ringSegments);
        
        const ringCanvas = document.createElement('canvas');
        ringCanvas.width = deviceConfig.textureSize;
        ringCanvas.height = deviceConfig.textureSize;
        const ringCtx = ringCanvas.getContext('2d');
        
        const ringGradient = ringCtx.createRadialGradient(
            deviceConfig.textureSize/2, deviceConfig.textureSize/2, 
            deviceConfig.textureSize * 0.15,
            deviceConfig.textureSize/2, deviceConfig.textureSize/2, 
            deviceConfig.textureSize/2
        );
        
        if (deviceConfig.isMobile) {
            ringGradient.addColorStop(0, 'rgba(230, 180, 70, 0.9)');
            ringGradient.addColorStop(0.3, 'rgba(200, 150, 50, 0.8)');
            ringGradient.addColorStop(0.6, 'rgba(220, 170, 60, 0.7)');
            ringGradient.addColorStop(1, 'rgba(220, 170, 60, 0.5)');
        } else {
            ringGradient.addColorStop(0, 'rgba(230, 180, 70, 0.95)');
            ringGradient.addColorStop(0.15, 'rgba(200, 150, 50, 0.9)');
            ringGradient.addColorStop(0.25, 'rgba(180, 130, 40, 0.85)');
            ringGradient.addColorStop(0.4, 'rgba(220, 170, 60, 0.8)');
            ringGradient.addColorStop(0.55, 'rgba(190, 140, 45, 0.75)');
            ringGradient.addColorStop(0.7, 'rgba(210, 160, 55, 0.7)');
            ringGradient.addColorStop(0.85, 'rgba(180, 130, 40, 0.6)');
            ringGradient.addColorStop(1, 'rgba(220, 170, 60, 0.5)');
        }
        
        ringCtx.fillStyle = ringGradient;
        ringCtx.fillRect(0, 0, deviceConfig.textureSize, deviceConfig.textureSize);
        
        const ringDetail = deviceConfig.isMobile ? 5000 : 15000;
        for (let i = 0; i < ringDetail; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = deviceConfig.textureSize * 0.15 + Math.random() * (deviceConfig.textureSize * 0.35);
            const x = deviceConfig.textureSize/2 + Math.cos(angle) * radius;
            const y = deviceConfig.textureSize/2 + Math.sin(angle) * radius;
            const brightness = Math.random() * 40;
            ringCtx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness}, ${deviceConfig.isMobile ? 0.2 : 0.3})`;
            ringCtx.fillRect(x, y, 1, 1);
        }
        
        const ringTexture = new THREE.CanvasTexture(ringCanvas);
        
        const ringMaterial = new THREE.MeshPhongMaterial({
            map: ringTexture,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.85,
            shininess: deviceConfig.isMobile ? 50 : 80,
            specular: 0x888888
        });
        
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = Math.PI / 2.2;
        ring.castShadow = !deviceConfig.isMobile;
        ring.receiveShadow = !deviceConfig.isMobile;
        scene.add(ring);
        
        const glowGeometry = new THREE.SphereGeometry(1.5, deviceConfig.isMobile ? 32 : 64, deviceConfig.isMobile ? 32 : 64);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0xffcc88,
            transparent: true,
            opacity: 0.15,
            side: THREE.BackSide
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        scene.add(glow);

        const outerGlowGeometry = new THREE.SphereGeometry(1.7, deviceConfig.isMobile ? 32 : 64, deviceConfig.isMobile ? 32 : 64);
        const outerGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xffaa44,
            transparent: true,
            opacity: 0.08,
            side: THREE.BackSide
        });
        const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
        scene.add(outerGlow);

        const saturnGroup = new THREE.Group();
        saturnGroup.add(saturn);
        saturnGroup.add(ring);
        saturnGroup.add(glow);
        saturnGroup.add(outerGlow);
        scene.add(saturnGroup);

        const originalScale = { x: 1, y: 1, z: 1 };
        const originalColor = saturnMaterial.color.clone();
        const originalPosition = saturnGroup.position.clone();

        let particles = [];
        let debris = [];
        let shockwaves = [];
        let fireRings = [];
        
        function createExplosionParticles() {
            const particleCount = deviceConfig.particleCount;
            
            for (let i = 0; i < particleCount; i++) {
                const size = Math.random() * 0.2 + 0.05;
                const particleGeometry = new THREE.SphereGeometry(size, deviceConfig.isMobile ? 6 : 12, deviceConfig.isMobile ? 6 : 12);
                const color = new THREE.Color();
                
                const rand = Math.random();
                if (rand < 0.25) {
                    color.setHex(0xff2200);
                } else if (rand < 0.5) {
                    color.setHex(0xff6600);
                } else if (rand < 0.7) {
                    color.setHex(0xffaa00);
                } else if (rand < 0.85) {
                    color.setHex(0xffff00);
                } else {
                    color.setHex(0xffffff);
                }
                
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(saturn.position);
                
                const speed = Math.random() * 0.2 + 0.08;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                particle.velocity = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta) * speed,
                    Math.sin(phi) * Math.sin(theta) * speed,
                    Math.cos(phi) * speed
                );
                
                particle.life = 1.0;
                particle.decay = Math.random() * 0.008 + 0.004;
                
                scene.add(particle);
                particles.push(particle);
            }
            
            const debrisCount = deviceConfig.debrisCount;
            for (let i = 0; i < debrisCount; i++) {
                const size = Math.random() * 0.4 + 0.15;
                const debrisGeometry = new THREE.BoxGeometry(size, size, size);
                const debrisMaterial = new THREE.MeshPhongMaterial({
                    color: 0xd4a574,
                    emissive: 0xff3300,
                    emissiveIntensity: 0.8,
                    shininess: 30
                });
                
                const debrisMesh = new THREE.Mesh(debrisGeometry, debrisMaterial);
                debrisMesh.position.copy(saturn.position);
                
                const speed = Math.random() * 0.12 + 0.04;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                debrisMesh.velocity = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta) * speed,
                    Math.sin(phi) * Math.sin(theta) * speed,
                    Math.cos(phi) * speed
                );
                
                debrisMesh.rotationSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3
                );
                
                debrisMesh.life = 1.0;
                
                scene.add(debrisMesh);
                debris.push(debrisMesh);
            }
            
            const shockwaveCount = deviceConfig.isMobile ? 2 : 3;
            for (let i = 0; i < shockwaveCount; i++) {
                const shockwaveGeometry = new THREE.RingGeometry(0.1, 0.3, deviceConfig.isMobile ? 64 : 128);
                const shockwaveMaterial = new THREE.MeshBasicMaterial({
                    color: i === 0 ? 0xffff00 : 0xff8800,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });
                const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
                shockwave.position.copy(saturn.position);
                shockwave.scale.set(1, 1, 1);
                shockwave.delay = i * 5;
                shockwave.rotation.x = Math.random() * Math.PI;
                shockwave.rotation.y = Math.random() * Math.PI;
                scene.add(shockwave);
                shockwaves.push(shockwave);
            }

            const fireRingCount = deviceConfig.isMobile ? 3 : 5;
            for (let i = 0; i < fireRingCount; i++) {
                const fireRingGeo = new THREE.TorusGeometry(0.5 + i * 0.3, 0.1, deviceConfig.isMobile ? 8 : 16, deviceConfig.isMobile ? 50 : 100);
                const fireRingMat = new THREE.MeshBasicMaterial({
                    color: i % 2 === 0 ? 0xff4400 : 0xff8800,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const fireRing = new THREE.Mesh(fireRingGeo, fireRingMat);
                fireRing.position.copy(saturn.position);
                fireRing.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.5;
                fireRing.delay = i * 3;
                scene.add(fireRing);
                fireRings.push(fireRing);
            }
        }

        function updateParticles() {
            if (particles.length === 0 && debris.length === 0 && 
                shockwaves.length === 0 && fireRings.length === 0) {
                return;
            }
            
            const updateBatchSize = deviceConfig.isMobile ? 10 : 20;
            
            for (let i = 0; i < particles.length; i += updateBatchSize) {
                const end = Math.min(i + updateBatchSize, particles.length);
                for (let j = i; j < end; j++) {
                    const particle = particles[j];
                    particle.position.add(particle.velocity);
                    particle.velocity.multiplyScalar(0.97);
                    particle.life -= particle.decay;
                    particle.material.opacity = particle.life;
                }
            }
            particles = particles.filter(p => {
                if (p.life <= 0) {
                    scene.remove(p);
                    return false;
                }
                return true;
            });
            
            for (let i = 0; i < debris.length; i += updateBatchSize) {
                const end = Math.min(i + updateBatchSize, debris.length);
                for (let j = i; j < end; j++) {
                    const d = debris[j];
                    d.position.add(d.velocity);
                    d.velocity.multiplyScalar(0.96);
                    d.rotation.x += d.rotationSpeed.x;
                    d.rotation.y += d.rotationSpeed.y;
                    d.rotation.z += d.rotationSpeed.z;
                    
                    d.life -= 0.006;
                    d.material.opacity = d.life;
                    d.material.emissiveIntensity = d.life * 0.8;
                }
            }
            debris = debris.filter(d => {
                if (d.life <= 0) {
                    scene.remove(d);
                    return false;
                }
                return true;
            });
            
            shockwaves.forEach(sw => {
                if (sw.delay > 0) {
                    sw.delay--;
                } else {
                    sw.scale.x += 0.5;
                    sw.scale.y += 0.5;
                    sw.material.opacity -= 0.015;
                    sw.rotation.z += 0.05;
                }
                
                if (sw.material.opacity <= 0) {
                    scene.remove(sw);
                }
            });
            shockwaves = shockwaves.filter(sw => sw.material.opacity > 0);
            
            fireRings.forEach(fr => {
                if (fr.delay > 0) {
                    fr.delay--;
                } else {
                    fr.scale.x += 0.15;
                    fr.scale.y += 0.15;
                    fr.scale.z += 0.15;
                    fr.material.opacity -= 0.02;
                    fr.rotation.z += 0.1;
                }
                
                if (fr.material.opacity <= 0) {
                    scene.remove(fr);
                }
            });
            fireRings = fireRings.filter(fr => fr.material.opacity > 0);
        }

        function triggerFlash() {
            const flash = document.getElementById('flashOverlay');
            flash.style.opacity = '1';
            setTimeout(() => {
                flash.style.opacity = '0';
            }, deviceConfig.isMobile ? 60 : 80);
        }

        function triggerScreenShake(duration) {
            if (deviceConfig.isMobile && duration > 15) {
                duration = 15;
            }
            
            const shakeOverlay = document.getElementById('shakeOverlay');
            let shakeFrames = 0;
            const maxShakeFrames = duration;
            
            const shake = () => {
                if (shakeFrames < maxShakeFrames) {
                    const intensity = (1 - shakeFrames / maxShakeFrames) * (deviceConfig.isMobile ? 6 : 10);
                    shakeOverlay.style.transform = `translate(${(Math.random() - 0.5) * intensity}px, ${(Math.random() - 0.5) * intensity}px)`;
                    shakeFrames++;
                    requestAnimationFrame(shake);
                } else {
                    shakeOverlay.style.transform = 'translate(0, 0)';
                }
            };
            shake();
        }

        function destroyPlanet() {
            if (currentAnimation) {
                cancelAnimationFrame(currentAnimation);
                currentAnimation = null;
            }
            
            if (isDestroyed && saturnGroup.scale.x < 0.15) return;
            
            isAnimating = true;
            isDestroyed = true;
            document.getElementById('planetStatus').textContent = 'DESTROYED!';
            document.getElementById('planetStatus').style.color = '#ff0000';
            document.getElementById('planetStatus').style.textShadow = '0 0 10px #ff0000';

            if (saturnGroup.scale.x > 0.4) {
                triggerFlash();
                triggerScreenShake(deviceConfig.isMobile ? 15 : 25);
                createExplosionParticles();
            }

            const startScale = saturnGroup.scale.x;
            const originalCameraPos = camera.position.clone();
            
            let frame = 0;
            const maxFrames = deviceConfig.animationFrames;
            
            const destroyAnimation = () => {
                frame++;
                const progress = frame / maxFrames;

                if (frame < 35 && !deviceConfig.isMobile) {
                    const shakeIntensity = 0.4 * (1 - frame / 35);
                    camera.position.x = originalCameraPos.x + (Math.random() - 0.5) * shakeIntensity;
                    camera.position.y = originalCameraPos.y + (Math.random() - 0.5) * shakeIntensity;
                    camera.position.z = originalCameraPos.z + (Math.random() - 0.5) * shakeIntensity * 0.3;
                } else {
                    camera.position.lerp(originalCameraPos, 0.08);
                }

                if (frame < 25 && !deviceConfig.isMobile) {
                    saturnGroup.position.x = originalPosition.x + (Math.random() - 0.5) * 0.5;
                    saturnGroup.position.y = originalPosition.y + (Math.random() - 0.5) * 0.5;
                    saturnGroup.position.z = originalPosition.z + (Math.random() - 0.5) * 0.3;
                } else {
                    saturnGroup.position.lerp(originalPosition, 0.1);
                }

                const targetScale = 0.08;
                const scale = startScale - (startScale - targetScale) * Math.pow(progress, 1.5);
                saturnGroup.scale.set(scale, scale, scale);

                if (frame < 40) {
                    saturnMaterial.color.lerp(new THREE.Color(0xff1100), deviceConfig.isMobile ? 0.08 : 0.12);
                    saturnMaterial.emissive = new THREE.Color(0xff4400);
                    saturnMaterial.emissiveIntensity = 3 * (1 - frame / 40);
                    ringMaterial.emissive = new THREE.Color(0xff6600);
                    ringMaterial.emissiveIntensity = 2 * (1 - frame / 40);
                } else {
                    saturnMaterial.color.lerp(new THREE.Color(0x111111), deviceConfig.isMobile ? 0.04 : 0.06);
                    saturnMaterial.emissiveIntensity *= 0.95;
                    ringMaterial.emissiveIntensity *= 0.95;
                }

                saturnGroup.rotation.y += deviceConfig.isMobile ? 0.08 : 0.12 * (1 + progress * 4);
                saturnGroup.rotation.x += deviceConfig.isMobile ? 0.04 : 0.06 * progress;
                saturnGroup.rotation.z += deviceConfig.isMobile ? 0.02 : 0.03 * progress;

                ring.material.opacity = (1 - progress) * 0.85;
                glow.material.opacity = (1 - progress) * 0.15;
                outerGlow.material.opacity = (1 - progress) * 0.08;

                if (currentGesture === 'open') {
                    camera.position.copy(originalCameraPos);
                    saturnGroup.position.copy(originalPosition);
                    isAnimating = false;
                    restorePlanet();
                    return;
                }

                if (frame < maxFrames) {
                    currentAnimation = requestAnimationFrame(destroyAnimation);
                } else {
                    saturnGroup.scale.set(0.08, 0.08, 0.08);
                    saturnGroup.position.copy(originalPosition);
                    camera.position.copy(originalCameraPos);
                    isAnimating = false;
                    currentAnimation = null;
                }
            };

            destroyAnimation();
        }

        function restorePlanet() {
            if (currentAnimation) {
                cancelAnimationFrame(currentAnimation);
                currentAnimation = null;
            }
            
            if (!isDestroyed && saturnGroup.scale.x > 0.92) return;
            
            isAnimating = true;
            isDestroyed = false;
            document.getElementById('planetStatus').textContent = 'Normal';
            document.getElementById('planetStatus').style.color = '#00ff00';
            document.getElementById('planetStatus').style.textShadow = '0 0 10px #00ff00';

            particles.forEach(p => scene.remove(p));
            particles = [];
            debris.forEach(d => scene.remove(d));
            debris = [];
            shockwaves.forEach(sw => scene.remove(sw));
            shockwaves = [];
            fireRings.forEach(fr => scene.remove(fr));
            fireRings = [];

            const startScale = saturnGroup.scale.x;
            let frame = 0;
            const maxFrames = deviceConfig.isMobile ? 60 : 90;
            
            const restoreAnimation = () => {
                frame++;
                const progress = frame / maxFrames;

                const easeProgress = progress < 0.65 ? 
                    Math.pow(progress / 0.65, 0.8) : 
                    1 - Math.pow((progress - 0.65) / 0.35, 2) * 0.12;
                
                const scale = startScale + (1 - startScale) * easeProgress;
                saturnGroup.scale.set(scale, scale, scale);

                saturnMaterial.color.lerp(originalColor, deviceConfig.isMobile ? 0.05 : 0.08);
                saturnMaterial.emissive = new THREE.Color(0x000000);
                saturnMaterial.emissiveIntensity = 0;
                ringMaterial.emissive = new THREE.Color(0x000000);
                ringMaterial.emissiveIntensity = 0;

                ring.material.opacity = Math.min(0.85, progress * 1.3);
                glow.material.opacity = Math.min(0.15, progress * 0.23);
                outerGlow.material.opacity = Math.min(0.08, progress * 0.12);

                saturnGroup.rotation.y += deviceConfig.isMobile ? 0.01 : 0.015;
                saturnGroup.rotation.x *= deviceConfig.isMobile ? 0.96 : 0.92;
                saturnGroup.rotation.z *= deviceConfig.isMobile ? 0.96 : 0.92;

                if (frame > 30) {
                    glowLight.intensity = 1 + Math.sin(frame * 0.3) * 0.3;
                }

                if (currentGesture === 'fist') {
                    isAnimating = false;
                    destroyPlanet();
                    return;
                }

                if (frame < maxFrames) {
                    currentAnimation = requestAnimationFrame(restoreAnimation);
                } else {
                    saturnGroup.scale.set(1, 1, 1);
                    saturnGroup.position.copy(originalPosition);
                    saturnMaterial.color.copy(originalColor);
                    ring.material.opacity = 0.85;
                    glow.material.opacity = 0.15;
                    outerGlow.material.opacity = 0.08;
                    glowLight.intensity = 1;
                    isAnimating = false;
                    currentAnimation = null;
                }
            };

            restoreAnimation();
        }

        function detectGesture(landmarks) {
            if (!landmarks || landmarks.length === 0) {
                return 'none';
            }

            const hand = landmarks[0];
            
            const wrist = hand[0];
            const thumbTip = hand[4];
            const indexTip = hand[8];
            const middleTip = hand[12];
            const ringTip = hand[16];
            const pinkyTip = hand[20];
            
            const indexBase = hand[5];
            const middleBase = hand[9];
            const ringBase = hand[13];
            const pinkyBase = hand[17];

            const thumbBase = hand[2];

            const indexCurled = distance3D(indexTip, indexBase) < 0.06;
            const middleCurled = distance3D(middleTip, middleBase) < 0.06;
            const ringCurled = distance3D(ringTip, ringBase) < 0.06;
            const pinkyCurled = distance3D(pinkyTip, pinkyBase) < 0.06;
            const thumbCurled = distance3D(thumbTip, thumbBase) < 0.08;
            
            const curledCount = [indexCurled, middleCurled, ringCurled, pinkyCurled, thumbCurled].filter(Boolean).length;

            const distances = [
                distance3D(wrist, indexTip),
                distance3D(wrist, middleTip),
                distance3D(wrist, ringTip),
                distance3D(wrist, pinkyTip)
            ];
            const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;

            const indexMid = hand[6];
            const middleMid = hand[10];
            const ringMid = hand[14];
            const pinkyMid = hand[18];
            
            const indexExtended = distance3D(indexTip, wrist) > distance3D(indexMid, wrist) * 1.2;
            const middleExtended = distance3D(middleTip, wrist) > distance3D(middleMid, wrist) * 1.2;
            const ringExtended = distance3D(ringTip, wrist) > distance3D(ringMid, wrist) * 1.2;
            const pinkyExtended = distance3D(pinkyTip, wrist) > distance3D(pinkyMid, wrist) * 1.2;
            
            const extendedCount = [indexExtended, middleExtended, ringExtended, pinkyExtended].filter(Boolean).length;

            const palmCenter = hand[9];
            const palmToFingers = [
                distance3D(palmCenter, indexTip),
                distance3D(palmCenter, middleTip),
                distance3D(palmCenter, ringTip),
                distance3D(palmCenter, pinkyTip)
            ];
            const avgPalmDistance = palmToFingers.reduce((a, b) => a + b, 0) / palmToFingers.length;

            const isFist = (curledCount >= 4) || (avgDistance < 0.13) || (extendedCount <= 1) || (avgPalmDistance < 0.08);
            const isOpen = (extendedCount >= 3) && (avgDistance > 0.17) && (avgPalmDistance > 0.12);

            if (isFist) {
                return 'fist';
            } else if (isOpen) {
                return 'open';
            } else {
                return 'neutral';
            }
        }

        function distance3D(point1, point2) {
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            const dz = point1.z - point2.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        const videoElement = document.getElementById('camera');
        const handStatusEl = document.getElementById('handStatus');
        const gestureStatusEl = document.getElementById('gestureStatus');
        const deviceModeEl = document.getElementById('deviceMode');
        
        if (deviceConfig.isMobile) {
            document.getElementById('statusPanel').classList.add('mobile');
            deviceModeEl.textContent = 'Mobile';
            deviceModeEl.style.color = '#ff9900';
            
            const mobileWarning = document.getElementById('mobileWarning');
            mobileWarning.style.display = 'block';
            setTimeout(() => {
                mobileWarning.style.opacity = '0';
                setTimeout(() => {
                    mobileWarning.style.display = 'none';
                }, 1000);
            }, 3000);
        } else {
            deviceModeEl.textContent = 'Desktop';
        }
        
        document.getElementById('deviceInfo').textContent = 
            `${deviceConfig.isMobile ? 'üì± Mobile' : 'üñ•Ô∏è Desktop'} Mode | Optimized for ${deviceConfig.isMobile ? 'performance' : 'quality'}`;

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: deviceConfig.isMobile ? 0 : 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handStatusEl.textContent = 'Yes';
                handStatusEl.style.color = '#00ff00';

                const gesture = detectGesture(results.multiHandLandmarks);
                
                if (gesture === 'fist') {
                    gestureStatusEl.textContent = '‚úä Fist';
                    gestureStatusEl.style.color = '#ff3333';
                    gestureStatusEl.style.textShadow = '0 0 8px #ff3333';
                    
                    if (currentGesture !== 'fist') {
                        currentGesture = 'fist';
                        gestureHoldTime = 0;
                    }
                    
                    gestureHoldTime++;
                    
                    if (gestureHoldTime >= GESTURE_HOLD_THRESHOLD || isAnimating) {
                        destroyPlanet();
                    }
                    
                } else if (gesture === 'open') {
                    gestureStatusEl.textContent = '‚úã Open';
                    gestureStatusEl.style.color = '#33ff33';
                    gestureStatusEl.style.textShadow = '0 0 8px #33ff33';
                    
                    if (currentGesture !== 'open') {
                        currentGesture = 'open';
                        gestureHoldTime = 0;
                    }
                    
                    gestureHoldTime++;
                    
                    if (gestureHoldTime >= GESTURE_HOLD_THRESHOLD || isAnimating) {
                        restorePlanet();
                    }
                    
                } else if (gesture === 'neutral') {
                    gestureStatusEl.textContent = 'ü§è Transitioning';
                    gestureStatusEl.style.color = '#ffaa33';
                    gestureStatusEl.style.textShadow = '0 0 5px #ffaa33';
                    
                    if (currentGesture !== 'neutral') {
                        gestureHoldTime = 0;
                    }
                    currentGesture = 'neutral';
                }
            } else {
                handStatusEl.textContent = 'No';
                handStatusEl.style.color = '#ff3333';
                gestureStatusEl.textContent = 'None';
                gestureStatusEl.style.color = '#666666';
                gestureStatusEl.style.textShadow = 'none';
                currentGesture = 'none';
                gestureHoldTime = 0;
            }
        });

        async function initCamera() {
            try {
                const videoConfig = deviceConfig.isMobile ? {
                    width: 640,
                    height: 480,
                    facingMode: 'user'
                } : {
                    width: 1280,
                    height: 720,
                    facingMode: 'user'
                };
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: videoConfig
                });
                
                videoElement.srcObject = stream;
                
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        resolve();
                    };
                });

                const cameraInstance = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: videoConfig.width,
                    height: videoConfig.height
                });
                
                cameraInstance.start();

                document.getElementById('loading').style.display = 'none';
                document.getElementById('statusPanel').style.display = 'block';
                initPanelToggle();

            } catch (error) {
                console.error('Camera error:', error);
                document.getElementById('loading').innerHTML = `
                    <h1 style="color: #ff3333;">‚ö†Ô∏è CAMERA ACCESS DENIED</h1>
                    <p style="margin-top: 20px; font-size: 16px;">Please allow camera access to control Saturn</p>
                    <p style="margin-top: 10px; font-size: 12px; color: #888;">Error: ${error.message}</p>
                    ${deviceConfig.isMobile ? '<p style="margin-top: 15px; font-size: 14px; color: #ff9900;">üì± Tips: Use front camera for best results</p>' : ''}
                `;
            }
        }
        
        function initPanelToggle() {
          const toggleBtn = document.getElementById('togglePanelBtn');
          const panelContent = document.getElementById('panelContent');
          
          toggleBtn.addEventListener('click', function() {
            panelContent.classList.toggle('expanded');
            panelContent.classList.toggle('collapsed');
            
            if (panelContent.classList.contains('collapsed')) {
              toggleBtn.textContent = '‚ñº';;
            } else {
              toggleBtn.textContent = '‚ñ≤' ;;
            }
          });
          
          if (deviceConfig.isMobile) {
            panelContent.classList.remove('expanded');
            panelContent.classList.add('collapsed');
            toggleBtn.textContent = '‚ñº';
          }
        }
        
        function animate() {
            requestAnimationFrame(animate);

            if (!isDestroyed && !isAnimating) {
                saturnGroup.rotation.y += deviceConfig.isMobile ? 0.003 : 0.004;
                saturnGroup.position.y = Math.sin(Date.now() * 0.0008) * (deviceConfig.isMobile ? 0.08 : 0.12);
                
                ring.rotation.z += deviceConfig.isMobile ? 0.0003 : 0.0005;
                
                glow.material.opacity = 0.15 + Math.sin(Date.now() * 0.003) * (deviceConfig.isMobile ? 0.02 : 0.03);
            }

            updateParticles();

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (deviceConfig.isMobile) {
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            }
        });

        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = deviceConfig.starCount;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * (deviceConfig.isMobile ? 100 : 150);
                positions[i + 1] = (Math.random() - 0.5) * (deviceConfig.isMobile ? 100 : 150);
                positions[i + 2] = (Math.random() - 0.5) * (deviceConfig.isMobile ? 100 : 150);
                
                const colorChoice = Math.random();
                if (colorChoice < 0.7) {
                    colors[i] = 1;
                    colors[i + 1] = 1;
                    colors[i + 2] = 1;
                } else if (colorChoice < 0.85) {
                    colors[i] = 1;
                    colors[i + 1] = 0.9;
                    colors[i + 2] = 0.7;
                } else {
                    colors[i] = 0.7;
                    colors[i + 1] = 0.9;
                    colors[i + 2] = 1;
                }
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                size: deviceConfig.isMobile ? 0.1 : 0.15,
                transparent: true,
                opacity: 0.9,
                vertexColors: true
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);

            const distantStarGeometry = new THREE.BufferGeometry();
            const distantStarCount = deviceConfig.isMobile ? 1000 : 2000;
            const distantPositions = new Float32Array(distantStarCount * 3);
            
            for (let i = 0; i < distantStarCount * 3; i += 3) {
                distantPositions[i] = (Math.random() - 0.5) * (deviceConfig.isMobile ? 200 : 300);
                distantPositions[i + 1] = (Math.random() - 0.5) * (deviceConfig.isMobile ? 200 : 300);
                distantPositions[i + 2] = (Math.random() - 0.5) * (deviceConfig.isMobile ? 200 : 300);
            }
            
            distantStarGeometry.setAttribute('position', new THREE.BufferAttribute(distantPositions, 3));
            
            const distantStarMaterial = new THREE.PointsMaterial({
                size: deviceConfig.isMobile ? 0.06 : 0.08,
                transparent: true,
                opacity: 0.5,
                color: 0xffffff
            });
            
            const distantStars = new THREE.Points(distantStarGeometry, distantStarMaterial);
            scene.add(distantStars);
        }
        
        document.addEventListener('touchmove', function(e) {
            if (e.scale !== 1) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('contextmenu', function(e) {
            if (deviceConfig.isMobile) {
                e.preventDefault();
            }
        });

        createStarField();
        initCamera();
        animate();
    </script>
</body>
</html>